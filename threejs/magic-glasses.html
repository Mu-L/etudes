<!DOCTYPE html>

<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="three147.min.js"></script>
		<link rel="stylesheet" href="../etudes.css">
	</head>
	
	<body>
		<h1 class="white">Magic glasses<a href="https://boytchev.github.io/etudes/">&larr;</a></h1>

		<script>

			
			
			// construct and setup the scene
			
			var renderer = new THREE.WebGLRenderer( {antialias:true} );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );
				document.body.style.margin = 0;
				document.body.style.overflow = 'hidden';

			var scene = new THREE.Scene();
				scene.background = new THREE.Color( 'black' );

			var camera = new THREE.PerspectiveCamera( 60, 1, 1, 10000 );
				camera.position.set( 0, 15, 100 );
				camera.lookAt( new THREE.Vector3(0, -10, 0) );

				
			var light = new THREE.SpotLight( 'white', 2 );
				light.position.set( 0, 50, 80 );
				light.angle = 1.2;
				light.penumbra = 1;
				light.distance = 150;
				light.target = new THREE.Object3D();
				light.target.position.set( 0, 0, 30);
				scene.add( light );
				scene.add( light.target );
				
			<!-- var ambLight = new THREE.AmbientLight( 'royalblue', 0.3 ); -->
				<!-- scene.add( ambLight ); -->

				
			window.addEventListener( 'resize', onWindowResize, false );
			onWindowResize();
			
			function onWindowResize( event )
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight, true );
			}			

	

cubeGeo = new THREE.CylinderGeometry( 3, 3, 6, 14, 14, true).rotateY(2*Math.PI*Math.random());
pos = cubeGeo.getAttribute( 'position' );
for( var i=0; i<pos.count; i++ )
{
	var x = pos.getX(i);
	var y = pos.getY(i);
	var z = pos.getZ(i);
	var k = (1.2-0.2*y)**2;
	k = 0.5+6*(1-(1-((-y+3)/6)**2)**0.5);
	k = 1.2/(0.01+y+3);
	x *= k;
	z *= k;
var dx = Math.sin(10*x-z*z)/10+Math.cos(10*x+z*z)/15;
var dz = Math.sin(x*x-10*z)/10+Math.cos(x*x+10*z)/15;	
	x += dx;
	z += dz;
	pos.setXYZ(i,x,y,z);
}
cubeGeo.computeVertexNormals();
frameGeo = new THREE.EdgesGeometry( cubeGeo );


			var cubeMat = new THREE.MeshPhysicalMaterial( {
					color: 'white',
					transparent: true,
					opacity: 1,
					side: THREE.DoubleSide,
					polygonOffset: true,
					polygonOffsetUnits: 0,
					polygonOffsetFactor: -1,
					metalness: 0,
					roughness: 1,
					sheen: 0.3,
					sheenColor: 'crimson',
					sheenRoughness: 0.5,
				} );
			var cubeMat2 = new THREE.LineBasicMaterial( {
					color: 0x505050,
					
//					transparent: !true,
//					opacity: 0.3,
//					side: THREE.DoubleSide,
//					side: THREE.BackSide,
//					wireframe: true,
				} );

			var ballMat = new THREE.MeshPhysicalMaterial( {
					color: 'gold',
					metalness: 0,
					roughness: 1,
				} );

			var ballGeo = new THREE.IcosahedronGeometry( 1, 3 );
			
			var ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 100, 100 ),
					cubeMat
				);
				ground.rotation.set( -Math.PI/2, 0, 0 );
				

			var houses = new THREE.Group();
//			houses.add( ground );
			scene.add( houses );
			
			var frames = new THREE.Group();
//					frames.renderOrder = -110;
			scene.add( frames );
			
			var lenses = 				new THREE.Mesh(
				new THREE.SphereGeometry( 10,  ),
				new THREE.MeshPhysicalMaterial( {color:new THREE.Color(0,5,0),transparent:true, opacity:1, transmission:1, ior:15, thickness:5, roughness:0, metalness:0  } )
			)
			lenses.scale.set( 1, 1, 0.1 );
			lenses.scale.set( 1, 1, 0.1 );

			<!-- var bar = 				new THREE.Mesh( -->
				<!-- new THREE.RingGeometry( 5, 100, 64, 1 ), -->
				<!-- new THREE.MeshPhysicalMaterial( {color:new THREE.Color(4,4,0),transparent:true, opacity:0,   } ) -->
			<!-- ) -->
			<!-- bar.renderOrder=-100; -->

			var magicGlasses = new THREE.Group();
			
			var tor = new THREE.Mesh(
					new THREE.TorusGeometry( 10, 0.5, 12, 64 ),
					new THREE.MeshStandardMaterial( {color: new THREE.Color(9,7,5), metalness: 0.9, roughness: 0, transparent:true, opacity:1} ),
				);
			
			magicGlasses.position.set( 0,10,80 );
			magicGlasses.add(lenses,tor
			//,bar
			);
			scene.add( magicGlasses );
			
			// create cubes

			var balls = new THREE.Group();
scene.add( balls );
			
			for( var i=0; i<16; i++ )
			{
			var ofs = 2*Math.PI*Math.random();
				var cube = new THREE.Mesh( cubeGeo, cubeMat );
					cube.scale.set( 2, 2, 2 );
//					cube.rotation.y = THREE.MathUtils.randFloat( 0, Math.PI );
					cube.position.x = 40 * (i%4) - 70;
					cube.position.z = 40 * (i>>2) - 70;
				houses.add( cube );

				var fracube = new THREE.LineSegments( frameGeo, cubeMat2 );
					fracube.scale.copy( cube.scale );
//					fracube.rotation.copy( cube.rotation );
					fracube.position.copy( cube.position );
				frames.add( fracube );
			
				for( var j=0; j<10; j++ )
				{
				var ball = new THREE.Mesh( ballGeo, ballMat );
					ball.scale.setScalar( 1 );
					ball.position.copy( cube.position );
					ball.angle = j/10*2*Math.PI;
					ball.offset = ofs;

				balls.add( ball );
				}
			}
			
			
						var clock = new THREE.Clock( true );

			
			
			function animate( t )
			{
				var dTime = clock.getDelta();
				
				houses.rotation.y = t/10000;
				balls.rotation.y = t/10000;
				frames.rotation.y = t/10000;
				
				magicGlasses.position.x = 13*Math.sin( 0.001*t );
				magicGlasses.rotation.set( -0.4-0.6*Math.cos( 0.0007*t ),0.3*Math.cos(0.001*t),0);
			//	magicGlasses.position.z = 40+40*Math.sin( 0.0013*t );
			//	magicGlasses.position.y = 20+15*Math.cos( 0.001*t );
				
				magicGlasses.position.z = 70;
				
				for( var ball of balls.children )
				{
//					ball.position.y += 1.5*(1 + Math.abs(ball.position.y)/10 )*dTime;
//					if( ball.position.y>40 ) ball.position.y -= 80;
					ball.position.y = 6 + 5*Math.tan( ball.angle + t/3000 + ball.offset );
					ball.scale.setScalar( 1+Math.abs(ball.position.y-6)/15 );
					<!-- if( ball.position.y < 6 ) -->
					<!-- { -->
						<!-- ball.scale.y = ball.position.y/6/2; -->
						<!-- ball.scale.x = 1.5-ball.scale.y/2; -->
						<!-- ball.scale.z = ball.scale.x; -->
					<!-- } -->
				}
				
				renderer.render( scene, camera );
			}
			
		</script>
	</body>
</html>